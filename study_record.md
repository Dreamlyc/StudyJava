# JRE和JDK

## JDK

- jvm虚拟机:Java程序运行的地方

- 核心类库:Java基础库，可直接使用

- 开发工具:javac、java、jdb、jhat ...

## JRE

- JRE是Java运行环境
- JVM、核心类库、运行工具

## JDK,JRE,JVM三者的包含关系

- JDK包含了JRE
- JRE包含了JVM

# Java基础概念

## 注释
在程序指定位置添加说明性的信息；简单理解，就是对代码的一种解释

- 单行注释：格式 : // 注释信息
- 多行注释：格式 : /* 注释信息 */
- 文档注释：格式 : /** 注释信息 */

## 关键字

被Java赋予了特定含义的英文单词

- 关键字的字母全部小写
- 常用的代码编辑器，针对关键字有特殊的颜色标记

class:用于创建/定义一个类，类是Java最基本的组成单元

class ClassName{}

## 字面量

数据在程序中的书写格式

- 整数类型：不带小数点的数字
- 小数类型：带小数点的数字
- 字符串类型：用双引号括起来的内容
- 字符类型：用单引号括起来的内容，只能有一个
- 布尔类型：表示真假 true false
- 空类型：空值 null

| 特殊字符     | 符号      | 含义                                      |
|----------|---------|-----------------------------------------|
| 制表符      | '\t'    | 在打印时，把前面字符串的长度补齐到8，或者是8的整数倍，最少1个空格，最多8个 |
| 换行符      | '\n'    |                                         |

## 变量

变量的定义格式：

数据类型 变量名=变量值;

```
int a = 10;
```

## 数据类型

整数类型：

| 关键字   | 取值范围                                     | 内存占用 |
|-------|------------------------------------------|------|
| byte  | -128~127                                 | 1    |
| short | -32867~32767                             | 2    |
| int   | -2147483648~2147483647                   | 4    |
| long  | -9223372036854775808~9223372036854775807 | 8    |

浮点数：

| 关键字    | 取值范围                          | 内存占用 |
|--------|-------------------------------|------|
| float  | -3.401298e-38~3.402823e+38    | 4    |
| double | -4.9000000e-324~1.797693e+308 | 8    |

字符：char  &emsp; 0~65535 &emsp; 2

布尔：boolean &emsp; true,false &emsp; 1

```
byte by1 = 10;
System.out.println(by1);
short sh1 = 20;
int int1 = 30;
long lg1 = 1235L;  // long型需要在数值后加 L 或者 l
float f1 = 10.1F;  // float型需要在数值后加 F 或者 f
double d1 = 20.2;
char ch = '中';
boolean fl = true;
```

## 标识符
给类，方法，变量等起的名字。
- 由数字、字母、下划线和$符组成
- 不能以数字开头
- 不能是关键字
- 区分大小写

建议：小驼峰命名法：方法、变量

- 标识符是一个单词时，全部小写，e.g:name
- 标识符由多个单词组成时，第一个单词首字母小写，其他单词首字母大写,e.g:firstName

大驼峰命名法：类名

- 标识符是一个单词时，首字母大写，e.g:Student
- 标识符由多个单词组成的时候，每个单词的首字母大写，e.g:GoodStudent

## 键盘录入

Java中内置的类为Scanner,这个类可以接收键盘输入的数据。

使用步骤：

- 导包：Scanner这个类在哪
```java
import java.util.Scanner;
```
- 创建对象
```
Scanner sc = new Scanner(System.in);
```
- 接收数据
```
int i = sc.nextInt();
```

项目(project)-->模块(module)-->包(package)-->类(class)


# 运算符

## 运算符和表达式

运算符：对字面量或变量进行操作的符号

表达式：用运算符把字面量或者变量连接起来，符合Java语法的式子

### 算术运算符

```
+  -  *  /  %
代码中由小数参与计算，结果有可能不精确。

字符串的'+'操作：
当"+"出现在字符串时，此时相当于字符串连接符，进行字符串拼接
"123"+123  // "123123"
连续"+"时从左到右逐个执行
1 + 99 + "字符串"   // "100字符串"
字符+字符 或 字符+数字时，通过ASCII码转换对应的数字进行相加

```
#### 隐式转换与强制转换
数据进行运算时，数据类型不一样不能够进行运算，需要转成一样的，才能运算。

- 隐式转换：取值范围小->取值范围大（自动类型提升）

byte、short、char三种类型的数据在运算的时候，都会直接先提升为int，然后进行运算。

- 强制转换：取值范围大->取值范围小
```
格式：目标类型数据 变量名(目标类型数据)被强转的数据
double a = 12.3;
int b = (int)a;
```

### 自增自减运算符

| 符号  | 作用  | 说明    |
|-----|-----|-------|
| ++  | 加   | 变量值+1 |
| --  | 减   | 变量值-1 |

可以在变量前面，也可以放在变量后面，单独写一行时，作用一样。

```java
public class ValueDemo2 {
    public static void main(String[] args) {
        int a = 10;
        a++;
        System.out.println(a);  // 11
        ++a;
        System.out.println(a);  // 12
        a--;
        System.out.println(a);  // 11
        --a;
        System.out.println(a);  // 10

        int b = 10,c = 10;
        // b++ 先用后加
        // ++c 先加后用
        System.out.println(b++);  // 10
        System.out.println(++c);  // 11
        
        int x = 10;
        int y = x++;
        int z = ++x;
        // x = 12,y = 10,z = 12
    }
}

```

### 赋值运算符

| 符号  | 作用    | 说明                  |
|-----|-------|---------------------|
| =   | 赋值    | int a = 10; 将10赋值给a |
| +=  | 加后赋值  | a+=b;将a+b的值赋给a      |
| -=  | 减后赋值  | a-=b;将a-b的值赋给a      |
| *=  | 乘后赋值  | a*=b;将a*b的值赋给a      |
| /=  | 除后赋值  | a/=b;将a/b的值赋给a      |
| %=  | 取余后赋值 | a%=b;将a%b的值赋给a      |

底层包含了强制类型转换

### 关系运算符
```
 ==  !=  >  >=  <  <=
```

### 逻辑运算符

```
&(与)  |(或)  ^(异或，相同为0，相异为1)  !(非)

短路逻辑运算符（提高程序运行效率）
&&(短路与)   ||(短路或)  
```
### 三元运算符

格式：关系表达式? 表达式1 : 表达式2;

求两个数的最大值。int max = a > b ? a : b;如果满足条件则返回a,否则返回b。

计算规制：
- 首先计算关系表达式的值
- 如果值为true,表达式1的值就是运算结果
- 如果值为false,表达式2的值就是运算结果


### 运算符优先级

| 优先级 | 运算符                  | 
|-----|----------------------|
| 1   | . () {}              | 
| 2   | ! ~ ++ --            | 
| 3   | * / %                | 
| 4   | + -                  | 
| 5   | << >> >>>            | 
| 6   | < <= > >= instanceof | 
| 7   | ==  !=               | 
| 8   | &                    | 
| 9   | ^                    | 
| 10  | 或                    | 
| 11  | &&                   | 
| 12  | 短路或                  | 
| 13  | ?:                   | 
| 14  | = += -= *= /= %= &=  | 

### 其他运算符
- & 逻辑与 0为false,1为true
- ( | ) 逻辑或 0为false,1为true
- << 左移  向左移动，低位补0
- ( >> )  右移  向右移动，高位补0或1
- ( >>> ) 无符号右移  向右移动，高位补0

# 流程控制语句

## 顺序结构

## 分支结构

```
if(关系表达式){
    语句体;
}
或者：
if(关系表达式){
    语句体1;
} else {
    语句体2;
}
或者：
if(关系表达式1){
    语句体1;
} else if(关系表达式1){
    语句体2;
} else {
    语句体3;
}
```

```
switch 语句：

switch(表达式){
    case 值1:
        语句体1;
        break;
    case 值2:
        语句体2;
        break;
    case 值3:
        语句体3;
        break;
        ...
    default:
        语句体n+1;
        break;
}
```
## 循环结构
- for
```
格式：

for (初始化语句;条件判断语句;条件控制语句){
    循环语句;
}
```


- while

```
格式
初始化语句;
while(条件判断语句){
    循环体语句;
    条件控制语句;
}
```


- do ... while

```
格式：
初始化语句;
do{
    循环体语句;
    条件控制语句;
} while(条件判断语句);

```

- 死循环
```
for(;;){
    循环语句;
}

while(true){
    循环语句;
}

do{
    循环语句
} while(true);
```

- 跳转控制
```
continue; // 跳过本次循环

break;  // 跳出循环

```

# 数组

## 数组介绍
用于存储多个同种数据类型（需要考虑隐式转换）值的容器。

## 数组的定义与静态初始化
```
格式1：
数据类型 [] 数组名
e.g：int [] array

格式二：
数据类型 数组名[]
e.g: int array[]

```
初始化：在内存中为数组容器开辟空间，并将数据存入容器的过程。

```
完整格式：
数据类型 [] 数组名 = new 数据类型[] {元素1,元素2,元素3,...};
e.g: int[] array = new int[]{11,12,13};
double[] array2 = new double[]{11.1,22.2,33.3};

简化格式：
数据类型 [] 数组名 = {元素1,元素2,元素3,...};
e.g: int[] array = {11,12,13};
double[] array = {11.1,22.2,33.3};
```
## 数组元素访问

数组名[索引]

- 索引：下标，角标
- 特点：从0开始，逐个+1增长，连续不间断

## 数组遍历

取出所有数据的过程

## 数组动态初始化

初始数据值未知
```
格式：
数据类型[] 数组名 = new 数据类型[数组长度];
e.g: int [] arr = new int[3];
```
区别：

- 动态初始化：手动指定数组长度，系统给出默认初始值。只明确元素个数，不明确具体数值时推荐使用
- 静态初始化：手动指定数组元素，系统会根据元素个数，计算出数组的长度。明确操作的具体数据时使用。


## 数组内存图

内存分配：

- 栈 
方法运行时使用的内存，比如main方法运行，进入方法栈中执行
- 堆
存储对象或者数组，new来创建的，都存储在堆内存
- 方法区
存储可以运行的class文件
- 本地方法栈
JVM在使用操作系统功能的时候使用，与开发无关
- 寄存器
给CPU使用，和开发无关

注意：从JDK8开始，取消方法区，新增元空间，把原来方法区的多种功能进行拆分，
有的功能放到了堆中，有的功能放到了元空间中。


## 数组常见问题

- 访问不存在的索引时，会引发索引越界异常

## 数组常见操作

- 求最值
- 求和
- 交换数据
- 打乱数据


# 方法（method）

## 什么是方法？

程序中最小的执行单元。

## 方法的格式

方法定义后不能直接运行，需要手动调用才能执行。

最简单的方法定义，带参数的方法定义，带返回值方法的定义。

```
public static 返回值类型 方法名 (参数){
    方法体;
    return 返回值;
}

调用：
方法名();
```

## 方法的重载

- 在同一个类中，定义了多个同名的方法，这些同名的方法具有相同的功能。
- 每个方法具有不同的参数类型或参数个数，这些同名的方法，就构成了重载关系。
- 简单记：同一个类中，方法名相同，参数不同的方法。与返回值无关。
- 参数不同：个数不同，类型不同，顺序不同


## 方法的内存

1.方法调用的基本内存原理

方法调用后入栈

2.方法传递基本数据类型的内存原理



3.方法传递引用数据类型的内存原理

### 基本数据类型与引用数据类型

栈内存
基本数据类型中，变量名存储的是真实的数据

堆内存
new创建的，地址记录在栈内存中，变量名存储其他空间的地址值


# 面向对象

学习获取已有对象并使用

学习如何自己设计对象并使用


## 设计对象并使用

### 类和对象

- 类（设计图）：对象共同特征的描述；
- 对象：真实存在的具体东西，先设计类，再获取对象

```
public class 类名{
    1、成员变量（代表属性，一般是名词）
    2、成员方法（代表行为，一般是动词）
    3、构造器
    4、代码块
    5、内部类
}

e.g:
public class Phone{
    String brand;
    double price;
    
    public void call(){
        
    }
    public void playGame(){
    
    }
}

类名 对象名 = new 类名();
Phone p = new Phone();
p.brand = "xiaomi";
p.price = 1999.98;
System.out.println(p.brand);
System.out.println(p.price);
p.call();
p.playGame();
```

### 注意事项

- 用来描述一类事物的类，专业叫做：Javabean类。
Javabean类中，不写main方法。
- 编写main方法的类，称为测试类。我们可以在测试类中创建javabean类的对象并进行赋值调用。
- 类名首字母建议大写，见名知意，驼峰模式。
- 一个java文件中可以定义多个class类，且只能一个类是public修饰，而且public修饰的类名必须称为代码的文件名。
- 实际开发中建议一个文件定义一个class类。
- 成员变量的完整定义格式为:修饰符 数据类型 变量名称=初始化值; 一般无需指定初始化值，存在默认值。
- 类的设计需要根据实际问题确定。

## 封装

面向对象的三大特征：封装、继承、多态

- 作用：告诉我们如何正确设计对象的属性和方法
- 对象代表什么，就得封装对应的数据，并提供数据对应的行为。
- 封装的好处：降低学习成本

## private关键字
- 权限修饰符
- 可以修饰成员（属性和方法）
- 被private修饰的成员只能在本类中才能访问

```java
public class GirlFriend{
    private String name;
    private int age;
    private String gender;
}
```
```java
public class GirlFriend{
    private String name;
    private int age;
    private String gender;
    
    // 对于每一个私有的成员变量，都需要提供get和set方法
    // set方法：给成员变量赋值
    // get方法：对外提供成员变量的值
    
    public void setAge(int a){
        if (a >= 18 && a <=50){
            age = a;
        } else {
            System.out.println("非法数据");
        }
    }
    
    public int getAge(){
        return age;
    }
}
```
## this关键字

### 成员变量与局部变量

- 成员变量：方法外，类里
- 局部变量：方法里
- 就近原则：成员变量与局部变量谁里的近就用谁的值
- this
```
this.成员变量
```

## 构造方法

- 构造方法的格式

构造方法也叫做构造器、构造函数。
作用：在创建对象时给成员变量进行赋值。

```
// 格式
public class Student{
    修饰符 类名(参数){
        方法体;
    }
}

特点：
1、方法名与类名相同，大小写一致
2、没有返回值类型，void也没有
3、没有具体的返回值（不能由return带回结果数据）
```
执行时机：

1、创建对象的时候由虚拟机调用，不能手动调用构造方法

2、每创建一次对象，就会调用一次构造方法

- 构造方法的作用

- 注意事项

如果没有定义构造方法，系统将给出一个默认的无参构造方法
如果定义了构造方法，系统将不在提供默认的构造方法。

构造方法可以重载

推荐使用方式：无论是否使用，都手动书写无参构造方法，和带全部参数的构造方法。

##  标准JavaBean

- 类名要见名知意
- 成员变量使用private修饰
- 提供至少两个构造方法（无参构造、带全部参数的构造方法）
- 成员方法
- 提供每个成员变量对应的set/get方法
- 如果还有其他行为，也需要写上

## 对象内存图

字节码文件在加载时进入内存的方法区

方法运行是所进入内存的变量存在与栈内存

new出来的东西会在堆内存中开辟空间并产生地址。

### 一个对象的内存图

Student s = new Student();

- 加载class文件
- 声明局部变量
- 在堆内存中开辟一个空间
- 默认初始化
- 显示初始化
- 构造方法初始化
- 将堆内存中的地址值赋值给左边的局部变量



### 多个对象的内存图

### 两个变量指向同一个对象的内存图

### this的内存原理

### 基本数据类型和引用数据类型的区别

### 局部变量和成员变量的区别

## 补充知识：成员变量、局部变量的区别

### 键盘录入

nextInt(); // 接收整数

nextDouble();  // 接收小数

next();  // 接收字符串

// 遇到空格，制表符，回车 就停止接收，这些符号后面的数据就不会接收了

nextLine();  // 接收字符串

// 可以接收 制表符，空格，遇到回车停止接收


# API

应用程序编程接口

## 字符串

String、StringBuilder、StringJonier、StringBuffer、Pattern、Matcher

### String

- java.lang.String类代表字符串，Java程序中的所有字符串文字都是此类的对象。
- 字符串的内容是不会改变的，它在对象创建后不能被更改。

#### 创建方式

- 直接赋值 String name = "hello world";
- new

| 构造方法                           | 说明               | 
|--------------------------------|------------------|
| public String()                | 创建空白字符串，不含任何内容   | 
| public String(String original) | 根据传入的字符串，创建字符串对象 | 
| public String(char[] chs)      | 根据字符数组，创建字符串对象   | 
| public String(byte[] chs)      | 根据字节数组，创建字符串对象   | 


#### 内存类型

- String Table(串池)，从JDK7开始，该部分从方法区挪到了堆内存。
- 变量名存储的是在串池中的地址。（串池中不存在时会创建，存在时会复用）

#### 常用方法（比较）

- == 符号的比较规则

基本数据类型：比较具体的数据值

引用数据类型：比较地址值

| 方法                                  | 说明                   | 
|-------------------------------------|----------------------|
| boolean equals方法(要比较的字符串)           | 完全一致结果为true,否则为false | 
| boolean equalsIgnoreCase方法(要比较的字符串) | 忽略大小写的比较             | 

public char charAt(int index):根据索引返回字符

public int length():返回此字符串的长度

String subString(int brginIndex,int endIndex):字符串截取
包头不包尾，包左不包右，只有返回值才是截取的小串。
String subString(int brginIndex):截取到末尾

String replace(旧值,新值) 替换

### StringBuilder

- Stringbuilder可以看成是一个容器，创建之后里面的内容是可变的
- 作用：提高字符串的操作效率
- 构造方法

| 方法                               | 说明                    | 
|----------------------------------|-----------------------|
| public StringBuilder()           | 创建一个空白课表字符串对象，不含有任何内容 | 
| public StringBuilder(String str) | 根据字符串的内同，来创建可变的字符串对象  | 

- 常用方法

| 方法                                | 说明                                     | 
|-----------------------------------|----------------------------------------|
| public StringBuilder append(任意类型) | 添加数据，并返回对象本身                           | 
| public StringBuilder reverse()    | 反转容器中的内容                               |
| public int length()               | 返回长度（字符出现的个数）                          | 
| public String toString()          | 通过toString()可以实现把StringBuilder转为String |


### StringJoiner概述

- 容器，创建之后的内容是可变的。
- 作用：提高字符串的操作效率，而且代码编写特别简洁
- JDK8之后出现

| 方法                                  | 说明                                    | 
|-------------------------------------|---------------------------------------|
| public StringJoiner(间隔符号)           | 创建StringJoiner对象，指定拼接的间隔符号            | 
| public StringJoiner(间隔符号,开始符号,结束符号) | 创建StringJoiner对象，指定拼接的间隔符号,开始符号，结束符号  |

- 成员方法

| 方法                             | 说明                     | 
|--------------------------------|------------------------|
| public StringJoiner add(添加的内容) | 添加数据，并返回对象本身           |
| public int length()            | 返回长度（字符出现的个数）          | 
| public String toString()       | 通过toString()返回拼接之后的字符串 |


### 字符串原理小结

#### 字符串拼接

- 如果没有变量参与，都是字符串直接相加，编译之后就是拼接之后的结果，会复用串池中的字符串。
- 如果有变量参与，每一行拼接的代码，都会在内存中创建新的字符串，浪费内存。

#### StringBuilder提高效率原理图

- 所有要拼接的内容都会往StringBuilder中放，不会创建很多无用的空间，节约内存。

首先创建一个容量为16的空间，如果数据过量，则扩容为：老容量*2+2=34

超出默认扩容容量后，会以实际容量为准。

## ArrayList

集合，自动扩容，长度可变

集合不能存基本数据类型，需要处理为包装类，可以存引用数据类型.

- 成员方法

| 方法                   | 说明                 | 
|----------------------|--------------------|
| boolean add(E e)     | 添加元素，返回值表示是否添加成功   |
| boolean remove(E e)  | 删除指定元素，返回值表示是否删除成功 | 
| E remove(int index)  | 删除指定索引的元素，返回被删除的元素 |
| E set(int index,E e) | 修改指定索引下的元素，返回原来的元素 |
| E get(int index)     | 获取指定索引的元素          | 
| int size()           | 集合长度，集合中元素的个数      |

### 基本数据类型对应的包装类
byte -> Byte

short -> Short

char -> Character

int -> Integer

long -> Long

float -> Float

double -> Double

boolean -> Boolean


### static

表示静态，Java中的修饰符，可以修饰成员方法，成员变量。

被static修饰的成员变量称为静态变量，静态变量随着类的加载而加载，优先于对象而出现在内存中。

特点：

- 被该类所有对象共享

调用方式

- 类名调用（推荐）
- 对象名调用


被static修饰的成员方法称为静态方法

特点：

- 多用在测试类（用来检查其他类是否书写正确，带有main方法的类，是程序的入口）和工具类（不描述任何事物，而是帮助我们做一些事情的类）中
- Javabean类（用于描述一类事务）中很少会用

调用方法：

- 类名调用（推荐）
- 对象名调用

#### 工具类

- 类名见名知意
- 私有化构造方法
- 方法定义为静态

#### static的注意事项

- 静态方法只能访问静态变量静态方法
- 非静态方法可以访问静态变量或者静态方法，也可以访问非静态的成员变量和非静态的成员方法。
- 静态方法中没有this关键字。
- this表示当前方法调用者的地址值。由虚拟机赋值。

#### main方法的重新认识

```java
public class HelloWorld{
    public static void main(String[] args) {
        System.out.println("hello world");
    }
}
// public  被JVM调用，访问权限足够大
// static  被JVM调用，不用创建对象，直接类名访问
// 因为main方法是静态的，所以测试类中其他方法也需要的是静态的
// void  被JVM调用，不需要给JVM返回值
// main  一个通用的名称，虽然不是关键字，但是被JVM识别
// String[] args  以前用于接收键盘录入数据的，现在无用，为了向下兼容，因此保留
```

### 继承

封装：对象代表什么，就封装对应的数据，并提供数据对应的行为。
                                                                 
继承：

- java中提供了关键字extends,用这个关键字，我们可以让一个类和另一个类建立起继承关系
- public class Student extends Person()
- Student称为子类（派生类），Person类称为父类（基类或超类）。

好处：

- 可以把多个子类中重复的代码抽取到父类中，提高代码的复用性。
- 子类可以在父类的基础上，增加其他的功能，使子类更强大。

学习：

- 自己设计
- 什么时候用继承？
- 当类与类之间，存在共同（共性）的内容，并满足子类是父类中的一种，就可以考虑使用继承，来优化代码。
- 

- 已有的

##### 继承的特点

- Java中只支持单继承，不支持多继承，但支持多层继承。
- 单继承：一个子类只能继承一个父类
- 不支持多继承：子类不能同时继承多个父类
- 支持多层继承：子类A可以继承父类B，父类B可以继承父类C。（间接父类）
- 每个类都直接或者简介的继承于Object
- 子类只能访问父类中的非私有的成员

##### 子类可以继承父类哪些内容

- 构造方法  非私有(不能)  private(不能)  
- 成员变量  非私有（能）  private（能，但是不能直接使用）
- 成员方法  非私有（能）  private（不能）
- 成员变量是否可以被继承:

```java
public class Fu{
    String gongfu;
}

public class Zi extends Fu{
    String gongfu;
}
```

```java
public class Fu{
    private String gongfu;
}

public class Zi extends Fu{
    String gongfu;
}
```
- 成员方法的继承
- 虚方法表（非private、非static、非final），继承时在继承父类的虚方法表的同时添加自己类中的虚方法。
- 只有父类中的虚方法才能被子类继承。

##### 继承中：成员变量的访问特点

- 就近原则：谁离我近，我就用谁
- 现在局部位置找，本类成员位置，父类成员位置，逐级往上。
```java
public class Fu{
    String name = "Fu";
}

public class Zi extends Fu{
    String name = "Zi";
    public void ziShow(){
        String name = "ziShow";
        System.out.println(name);
        System.out.println(this.name);
        System.out.println(super.name);
    }
}

// ziShow
// Zi
// Fu
```

##### 成员方法的访问特点

- 直接调用时满足就近原则，同样可以用this,super指明调用者
- 方法的重写：当父类的方法不能满足子类现在的需求时，需要进行方法重写
- 书写格式：在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。
- @Override重写注解：
- @Override是放在重写后的方法上，校验子类重写时的语法是否正确。
- 加上注解后如果有红色波浪线，表示语法错误
- 建议重写方法都加@Override注解，代码安全，优雅！
- 方法重写的本质：对虚方法表的覆盖
- 方法重写的注意事项和要求：
- 重写方法的名称、形参列表必须和父类中的一致。
- 子类重写父类方法时，访问权限子类必须大于等于父类（空着不写 < protected < public）
- 子类重写父类方法时，返回值类型必须小于或等于父类
- 建议：重写的方法尽量和父类保持一致
- 私有方法不能被重写
- 子类不能重写父类的静态方法，如果重写会报错。
- 只有被添加到虚方法表中的方法才能被重写。

##### 构造方法的特点

- 父类中的构造方法不会被子类继承。
- 子类中所有的构造方法默认先访问父类中的无参构造，再执行自己。
- 子类在初始化时，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。
- 子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化。
- 子类构造方法的第一行语句默认都是super(),不写也存在，且必须在第一行。
- 如果想要调用父类的有参构造，必须手动写super()进行调用。

```java
public class Person{
    String name;
    int age;
    
    public Person(){}
    
    public Person (String name,int age){
        this.name = name;
        this.age = age;
    }
}
```
```java
public class Student extends Person{
    public Student(){
        super();
        System.out.println("子类的空参构造");
    }
    public Student(String name,int age){
        super(name,age);
    }
}
```

##### this、super使用总结

- this可以理解为一个变量，表示当前方法调用者的地址值；
- super代表父类的存储空间

| 关键字   | 访问成员变量                    | 访问成员方法                   | 访问构造方法                  |
|-------|---------------------------|--------------------------|-------------------------|
| this  | this.成员变量 <br/>访问本类成员变量   | this.成员方法 <br/>访问本类成员方法  | this(...) <br/>访问本类构造方法 | 
| super | super.成员变量 <br/>访问父类类成员变量 | super.成员方法 <br/>访问父类成员方法 | this(...) <br/>访问父类构造方法 | 

### 包、final、权限修饰符、代码块

#### 什么是包？

- 包就是文件夹，用来管理各种不同功能的Java类，方便后期代码维护
- 包名规则：公司域名反写+包的作用，需要全部英文小写，见名知意。
- 全类名（全限定名） com.lyc.testpkg.Student
- 使用其他类时，需要使用全类名
- 导包 import com.lyc.testpkg.Student
- 使用同一个包中的其他类时，不需要导包
- 使用java.lang包中的类时，不需要导包
- 其他情况都需要导包
- 如果同时使用两个包中的同名类，需要用到全类名。

#### final

- 可以修饰
- 方法：表示该方法是最终方法，不能被重写
- 类：表明该类是最终类，不能被继承
- 变量：称为常量，只能被赋值一次
- 实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性
- 命名规范
- 单个单词：全部大写
- 多个单词：全部大写，单词间用下划线隔开
- 细节：
- final修饰的变量是基本类型，那么变量存储的数据值不能发生改变。
- final修饰的变量是引用类型，那么变量存储的地址值不能发生改变，对象内部的可以改变
- 字符串是不可变的

#### 权限修饰符

- 用于控制一个成员能够被访问的范围。
- 作用范围从小到大：private < 空着不写(缺省/默认) < protected < public

| 修饰符       | 同一个类中 | 同一个包中，其他类 | 不同包下的子类 | 不同包下的无关类 |
|-----------|-------|-----------|---------|----------|
| private   | 对     |           |         |          | 
| 空着不写      | 对     | 对         |         |          |
| protected | 对     | 对         | 对       |          | 
| public    | 对     | 对         | 对       | 对        |

- 实际开发中，一般只用private和public,成员变量私有，成员方法公开
- 特例：如果方法中的代码是抽取其他方法中共性代码，这个方法一般也私有。

#### 代码块

- 局部代码块

提前结束变量的作用周期，节约内存。

- 构造代码块

写在成员位置的代码块，将多个构造方法中重复的代码抽取出来，执行时机优先于构造方法执行。

- 静态代码块

格式: static {}

特点：需要通过static关键字修饰，随着类的加载而加载，并且自动触发，只执行一次。

使用场景：在类加载的时候，作一些数据初始化的时候使用

### 抽象类

#### 抽象类的定义格式

- 抽象方法：将共性的行为（方法）抽取到父类之后，由于每一个子类执行的内容是不一样的，所以在父类中不能确定具体的方法体，该类方法就定义为抽象方法。
- 抽象类：如果一个类中存在抽象方法，那么该类就必须声明为抽象类。

#### 抽象方法的定义格式

- 抽象方法的定义格式：public abstract 返回值类型 方法名(参数列表);
- 抽象类的定义格式:public abstract class 类名{}
- 注意事项
- 抽象类不能实例化
- 抽象列中不一定有抽象方法，有抽象方法的类一定是抽象类
- 可以有构造方法
- 抽象类的子类，要么重写抽象类中的所有抽象方法，要么是抽象类

#### 子类继承抽象类之后，如何重写抽象方法

强制重写

### 接口

某种行为的规则，对行为的抽象，与抽象类区分（抽象类一般用于父类）

#### 为什么有接口？

#### 如何定义一个接口

- 接口使用关键字interface定义
- public interface 接口名{}
- 接口不能实例化
- 接口与类之间是实现关系，通过implements关键字表示
- public class 类名 implements 接口名{}
- 接口的子类（实现类）要么重写接口中所有的抽象方法，要么是抽象类
- 注意：
- 接口和类之间的实现关系，可以单实现，也可以多实现
- public class 类名 implements 接口名1，接口名2{}

#### 如何使用一个接口


#### 接口里面成员的特点

- 成员变量
- 只能是常量
- 默认修饰符: public static final
- 构造方法
- 没有
- 成员方法
- 只能是抽象方法
- 默认修饰符：public abstract
- JDK7以前：接口中只能定义抽象方法。
- JDK8：接口可以定义有方法体的方法（默认、静态）
- JDK9：接口中可以定义私有方法

#### 接口与类之间的关系

- 类和类的关系
- 继承关系，只能单继承，不能多继承，但可以多层继承
- 类和接口的关系
- 实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口
- 接口与接口的关系
- 继承关系，可以单继承，也可以多继承

#### JDK8开始接口中新增的方法

- JDK7以前：接口中只能定义抽象方法。
- JDK8：接口可以定义有方法体的方法（默认、静态）
- JDK9：接口中可以定义私有方法。
- JDK8以后允许在接口中定义默认方法，需要使用关键字default修饰
- 作用：解决接口升级问题
- 接口中默认方法的定义格式
- 格式：public default 返回值类型 方法名（参数列表）{}
- 范例：public default void show(){}
- 接口中默认方法的注意事项：
- 默认方法不是抽象方法，所以不强制重写，但是如果被重写，重写的时候去掉default关键字
- public可以省略，default不能省略
- 如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写。
- 允许在接口中定义静方法，需要用static修饰
- 格式：public static 返回值类型 方法名（参数列表）{}
- 范例：public static void show(){}
- 接口中静态方法的注意事项
- 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用
- public可以省略，static不能省略

- JDK9添加私有方法(两种，普通的私有 静态的私有)
- 格式1：private static 返回值类型 方法名（参数列表）{}
- 范例1：private void show(){}
- 格式2：private static 返回值类型 方法名（参数列表）{}
- 范例2：private static void method(){}

#### 接口的应用

- 接口类型 j = new 实现类对象();
- 接口代表规则，是行为的抽象，想要哪个类拥有一个行为，就让这个类实现对应的接口就可以。
- 当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称为接口多态。

#### 适配器设计模式

- 设计模式（Design pattern）是一套被反复使用，多数人知晓的，经过分类编目的代码设计经验的总结。
- 使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码的可靠性、程序的重用性。
- 解决各种问题的套路
- 适配器设计模式：解决接口与接口实现类之间的矛盾问题。
- 当一个接口中抽象方法过多，但是我只要使用其中一部分的时候，就可以适配器设计模式。
- 步骤：
- 编写一个中间类XXXAdapter,实现对应的接口
- 对接口的抽象方法进行空实现
- 让真正的实现类继承中间类，并重写需要用的方法。
- 为了避免其他类创建适配器类对象，中间的适配器类用abstract进行修饰。

### 多态

- 同类型的对象，表现出的不同形态
- 父类类型 对象名称 = 子类对象;
- 有继承/实现关系;
- 有父类引用指向子类对象
- 有方法重写
- 使用父类型作为参数，可以接收所有子类对象
- 体现多态的扩展性与便利

#### 多态调用成员的特点

- 变量调用：编译看左边（父类），调用也看左边
- 方法调用：编译看左边，运行看右边（子类）
- Fu f = new Zi()

#### 多态的优势

- 在多态的形式下，右边的对象可以实现解耦合，便于扩展和维护。
- 定义方法时，使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利。

#### 多态的劣势

- 不能调用子类的特有功能。

#### 解决方法

- 强制转换 Zi z = (Zi) f; 
- a instanceof Dog //判断a是否是Dog类型

```
// 先判断类型，如果是，直接转换，如果不是，结果为false
if(a instanceof Dog d){
    d.lookHome();
} else if (a instanceof Cat c){
    c.catchMouse();
}
```

### 内部类

- 类的五大成员：属性、方法、构造方法、代码块、内部类
- 内部类：在一个类里面，再定义一个类

```java
public class Outer {
    // 外部类
    public class  Inner{
        // 内部类
    }
}

public  class Test{  // 外部其他类
    public static void main(String[] args) {
        
    }
}
```

```java
import java.io.StringReader;

public class Car {
    String carName;
    int carAge;
    int carColor;
    class Engine{
        String engineName;
        int engineAge;
    }
    Engine e = new Engine();
}
// 内部类表示事物是外部类的一部分
// 内部类单独出现没有任何意义
```
- 内部类的访问特点：
- 内部类可以直接访问外部类的成员，包括私有
- 外部类要访问内部类的成员，必须创建对象

#### 成员内部类

- 写在成员位置的，属于外部类的成员。
- 成员内部类可以被一些修饰符所修饰，如 private、default、protected（本包，其他包子类）、public、static等
- 在成员内部类中，JDK16之前不能定义静态变量
- 获取成员内部类对象
- 方式一、在外部类中编写方法，对外提供内部类的对象。
- 方式二、直接创建格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象;
- Outer.Inner oi = new Outer().new Inner();
- 外部类成员变量和内部类成员变量重名时，在内部类访问时：Outer.this.变量名

#### 静态内部类

- 静态内部类只能访问外部类的静态变量和静态方法，如果想要访问非静态的需要创建对象。
- 创建静态内部类对象的格式：外部类名。内部类名 对象名 = new 外部类名。内部类名();
- 调用非静态方法的格式：先创建对象，再调用对象。
- 调用静态方法的格式：外部类名.内部类名.方法名();
- 只要是静态的东西，都可以直接用类名. 直接获取

#### 局部内部类

- 将内部类定义在方法里面就叫做局部内部类，类似于方法中的局部变量
- 外界无法直接调用，需要在方法内部创建对象并使用。

#### 匿名内部类

- 本质上就是隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置。
- 格式：
- new 类名或者接口名(){
    重写方法; };
- 包含了实现/继承关系，方法的重写，创建对象。
- 当方法的参数是接口或者类时，
- 以接口为例，可以传递这个接口的实现类对象，如果实现类只要使用一次，就可以用匿名内部类简化代码。

###### 拼图小游戏

- 打包exe
- 一定包含图像化界面
- 代码要打包起来
- 图片打包起来
- JDK打包

- 核心步骤
- 把所有代码打包成一个压缩包，jar后缀的压缩
- 把jar包转换成exe安装包
- 把第二步的exe,图片，JDK整合在一起，变成最终的exe安装包

### 常用API

#### Math


#### System

- 工具类，提供系统相关的方法
- 计算机中的时间原点 1970年1月1日 00：00：00，C语言生日
- 东八区：1970年1月1日 08：00：00

| 方法                                                    | 说明                 | 
|-------------------------------------------------------|--------------------|
| public static void exit(int status)                   | 终止当前运行的JAVA虚拟机     |
| public static long currentTimeMillis()                | 返回当前系统的时间毫秒值形式     | 
| public static void arraycopy(源数组,起始索引，目的数组，起始索引，拷贝个数) | 数组拷贝               |


#### Runtime

- 表示当前虚拟机的运行环境

| 方法                                  | 说明                        | 
|-------------------------------------|---------------------------|
| public static Runtime getRuntime()  | 当前系统的运行环境对象               |
| public void exit(int status)        | 停止虚拟机                     | 
| public int availableProcessors()    | 获取CPU的线程数                 |
| public long maxMemory()             | JVM能从系统中获取总内存大小（单位byte）   |
| public long totalMemory()           | JVM已经从系统中获取的总内存大小（单位byte） |
| public long freeMemory()            | JVM剩余内存大小（单位byte）         |
| public Process exec(String command) | 运行cmd命令                   |

#### Object和Objects

- Object是Java中的顶级父类，所有的类都直接或者间接的继承于Object类。
- Object类中的所有方法都可以被所有子类访问

| 方法                                | 说明                        | 
|-----------------------------------|---------------------------|
| public object()                   | 空参构造                      |
| public String toString()          | 返回对象的字符串表示形式              | 
| public boolean equals(Object obj) | 比较两个对象是否相等                |
| protected Object clone(int a)     | 对象克隆                      |

- 如果一个接口里面没有抽象方法，表示当前接口是一个标记性接口
- Cloneable表示一旦实现，那么当前对象就可以被克隆
- 细节：
- 1、重写Object中的clone方法
- 2、让javabean类实现Cloneable接口
- 3、创建原对象并调用clone就可以

- 浅克隆 不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来
- 深克隆 基本数据类型直接拷贝，字符串复用，引用数据类型会重新创建新的
- 第三方工具（gson）

- Objects工具类

| 方法                                              | 说明                       | 
|-------------------------------------------------|--------------------------|
| public static boolean isNull(Object obj)        | 判断对象是否为null,为null返回true  |
| public static boolean nonNull(Object obj)       | 判断对象是否为null,与isNull的结果相反 | 
| public static boolean equals(Object a,Object b) | 先做非空判断，比较两个对象            |


#### BigInteger和BigDecimal

- Java中整数有：byte(1字节),short（2字节）,int（4字节）,long（8字节）

| 方法                                          | 说明                         | 
|---------------------------------------------|----------------------------|
| public BigInteger(int num,Random rnd)       | 获取随机大整数，范围：【0~2的num次方-1】   |
| public BigInteger(String val)               | 获取指定的大整数                   | 
| public  BigInteger(String val，int radix)    | 获取指定进制的大整数                 |
| public  static BigInteger valueOf(long val) | 静态方法和获取BigInteger的对象，内部有优化 |

- 该对象一旦创建，内部记录的值不能发生改变
- BigDecimal

| 类型     | 占用字节数 | 总bit位  | 小数部分bit位 |
|--------|-------|--------|----------|
| float  | 4个字节  | 32个bit | 23个bit   |
| double | 8个字节  | 64个bit | 52个bit   |

- 用于小数的精确运算
- 用来表示很大的小数
- 如果要表示的数字不大，没有超出double的取值范围，建议使用静态方法（valueOf）
- 如果要表示的数字比较大，超出double的取值范围，建议使用构造方法

| 方法                                                 | 说明   | 
|----------------------------------------------------|------|
| public static BigDecimal valueOf(double val)       | 获取对象 |
| public BigDecimal add(BigDecimal val)              | 加法   | 
| public BigDecimal subtract(BigDecimal val)         | 减法   |
| public BigDecimal multiply(BigDecimal val)         | 乘法   |
| public BigDecimal divide(BigDecimal val)           | 除法   |
| public BigDecimal divide(BigDecimal val,精确几位,舍入方式) | 除法   |

#### 正则表达式

- 正则表达式可以校验字符串是否满足一定的规则，并用来校验数据格式的合法性。
- 在一段文本中查找满足要求的内容

- 字符类（只匹配一个字符）

| 方法            | 说明                       | 
|---------------|--------------------------|
| [abc]         | 只能是a,b或c                 |
| [^abc]        | 除了a,b,c之外的任何字符           | 
| [a-zA-Z]      | a到z A到Z，包括范围             |
| [a-d[m-p]]    | a到d 或者m到p                | 
| [a-z&&[def]]  | a-z和def的交集 为d e f        |
| [a-z&&[^bc]]  | a-z和非bc的交集（等同[ad-z]）     | 
| [a-z&&[^m-p]] | a-z和除了m-p的交集（等同[a-lq-z]） |

- 预定义字符（只匹配一个字符）

| 方法  | 说明                     | 
|-----|------------------------|
| .   | 任何字符                   |
| \d  | 一个数字：[0-9]             | 
| \D  | 非数字：[^0-9]             |
| \s  | 一个空白字符：[\t\n\x0B\f\r]  | 
| \S  | 非空白字符[^\s]             |
| \w  | [a-zA-Z_0-9] 英文 数字 下划线 | 
| \W  | [^\w] 一个非单词字符          | 

- 数量词

| 方法     | 说明           | 
|--------|--------------|
| X?     | X,一次或0次      |
| X*     | X，0次或多次      | 
| X+     | X，一次或多次      |
| X{n}   | X，正好n次       | 
| X{n,}  | X，至少n次       |
| X{n,m} | X，至少n次但不超过m次 | 
| ()     | 分组           |
| ^      | 取反           | 
| &&     | 交集           |

| 方法                                                   | 说明                | 
|------------------------------------------------------|-------------------|
| public String[] matches(String regex)                | 判断字符串是否满足正则表达式的规则 |
| public String replaceAll(String regex,String newStr) | 按照正则表达式进行替换       | 
| public String[] split（String regex）                  | 按照正则表达式的规则进切割字符串  |

- 分组规则
- 规则1：从1开始，连续不间断
- 规则2：以左括号为基准，最左边的是第一组，其次为第二组，以此类推
- (\\d+)(\\d+)(\\d+)   ->  \\d+  \\d+  \\d+
- (\\d+(\\d+))(\\d+)   ->  \\d+\\d+   \\d+   \\d+

- 捕获分组：后续还需要使用本组的数据
- 正则内部使用：\\组号
- 正则外部使用：$组号

- 非捕获分组，分组之后不需要使用本组数据，仅仅是把数据括起来

| 符号     | 含义            | 举例                  |
|--------|---------------|---------------------|
| (?:正则) | 获取所有          | Java(?:8(或)11(或)17) |
| (?=正则) | 获取前面的部分       | Java(?=8(或)11(或)17) |
| (?!正则) | 获取不是指定内同的前面部分 | Java(?!8(或)11(或)17) |



#### JDK7时间类 SimpleDateFormat类作用

- public Date()
- public Date(long date)
- public void setTime(long time)
- public long getTime()

- 格式化：把时间转换为符合阅读习惯的
- 解析：把字符串表示的时间变成Date对象

| 构造方法                                    | 说明                           | 
|-----------------------------------------|------------------------------|
| public SimpleDateFormat()               | 构造一个SimpleDateFormat，使用默认格式  |
| public SimpleDateFormat(String pattern) | 构造一个SimpleDateFormat，使用指定的格式 | 

| 常用方法                                  | 说明               | 
|---------------------------------------|------------------|
| public final String format(Date data) | 格式化（日期对象 -> 字符串） |
| public Date parse(String source)      | 解析（字符串 -> 日期对象）  |

- 常用的格式
- y 年 M 月 d 日 H 时 m 分 s 秒
- yyyy-MM-dd HH:mm:ss

#### Calendar

- Calendar代表了系统当前时间的日历对象，可以单独修改、获取时间中的年，月，日
- 细节: Calendar是一个抽象类，不能直接创建对象
- 获取Calendar日历类对象的方法

| 方法名                                      | 说明             | 
|------------------------------------------|----------------|
| public static Calendar getInstance()     | 获取当前时间的日历对象    |
| public final Date getTime()              | 获取日期对象         |
| public final  setTime(Date date)         | 给日历设置日期对象      |
| public long getTimeInMillis()            | 拿到时间毫秒值        |
| public void setTimeInMillis(long millis) | 给日历设置时间毫秒值     |
| public int  get(int field)               | 取日历中的某个字段信息    |
| public void set(int field,int value)     | 修改日历中的某个字段信息   |
| public void add(int field,int amount)    | 为某个字段增加/减少指定的值 |

- 日历对象的获取
- 细节：calendar是一个抽象类，不能直接new，而是通过一个静态方法获取到子类对象

#### JDK8新增的时间对象

- JDK8时间日期对象都是不可变的，解决了多线程环境下的数据安全的问题

##### Date时间类
- ZoneId:时区
- Instant:时间戳
- ZoneDateTime:带时区的时间
##### 日期格式化类SimpleDateFormat
- DateTimeFormatter用于时间的格式化和解析
##### 日历类Calender
- LocalDate:年、月、日
- LocalTime:时、分、秒
- LocalDateTime:年月日时分秒
##### 工具类
- Duration : 时间间隔（秒，纳秒）
- Period : 时间间隔（年，月，日）
- ChronoUnit : 时间间隔（所有单位）

#### 包装类
- 基本数据类型对应的引用类型
- JDK5之后提出了自动装箱和自动拆箱机制
- 自动装箱：把基本数据类型自动变成对应的包装类
- 自动拆箱：把包装类自动的变成对象的基本数据类型
- 直接赋值就可以创建相关对象

| 成员方法                                       | 说明               | 
|--------------------------------------------|------------------|
| public static String toBinaryString(int i) | 得到二进制            |
| public static String toOctalString(int i)  | 得到八进制            |
| public static String toHexString(int i)    | 得到十六进制           |
| public static int parseInt(int i)          | 将字符串类型转换为int型的整数 |














